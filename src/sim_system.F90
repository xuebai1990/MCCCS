module sim_system
  use var_type,only:dp,default_path_length
  use util_runtime,only:err_exit
  use util_string,only:integer_to_string
  use util_files,only:get_iounit
  use util_search,only:LookupTable
  implicit none
  save

!==========================================================!
!=============== General Programming Advice ===============!
!==========================================================!
! Ideally, global variables should be kept to a MINIMUM. Variables below should go into their separate modules (e.g., MPI-related variables to util_mp, volume-moves-related variables to moves_volume). Exposing too many variables where they are not needed increases the chance that they are modified inadvertently.

! In many cases, things that you feel are "required" globally (for example when outputing swap statistics, you may want counters defined in transfer_swap available in the main program) can be delegated (calling the subroutine output_swap_stats, defined also in transfer_swap, eliminates the need to expose internal variables of transfer_swap)

! The ideas of software engineering are broad. Not every principle there can be conveniently implemented using Fortran. However, you should always try to look for a general solution than an ad-hoc fix. When problems you are dealing with grow in complexity (they inevitably will), you will find solutions that are general in nature and clear in logic are easier to extend and maintain.

! With computer programming, if you find yourself doing the same thing twice, odds are that there is a better way to it. Spend 10 minutes (even hours) to learn a technique that can be implemented in 1 minute, rather than spend 1 minute to come up with a technique that takes 10 minutes. Even if the learning phase takes longer, it will usually pay off in the long run: you may likely apply the better method many times in the future and you have sharpened your programming skills.
!==========================================================!

  !=== Information about the system ===

  !*** PARAMETERS FOR ENSEMBLE ***
  logical::lnpt& !< if LNPT=.TRUE. then a NPT volume move is used to equilibrate with a pressure bath (implies cubic simulation boxes) else an NVT simulation is performed
   ,lgibbs& !< if LGIBBS=.TRUE. then a Gibbs-ensemble simulation is performed (implies cubic simulation boxes)
   ,lgrand& !< if LGRAND=.TRUE. then simulation is performed in the grand-canonical ensemble
   ,lanes& !< if LANES=.TRUE. then simulation is performed in the adiabatic nuclear and electronic sampling technique for polarizable force fields
   ,lvirial& !<! if LVIRIAL=.TRUE. then one chain will be simulated in each box independently and the second virial coefficient will be calculated for their interactions at a series of distances along the x-axis
   ,lmipsw& !< if lmipsw is true, then thermodynamic integration is performed for the phases, fort.35 must be supplied if so
   ,lexpee& !< if lexpee is true, then expanded esnemble is performed for the phases, fort.44 must be supplied if so
   ,ldielect !< if LDIELECT=.TRUE. then dielectric constant will be calculated and LEWALD must be .TRUE. Correct only in NVT ensemble

  !*** PARAMETERS FOR BOUNDARY CONDITIONS ***
  logical,parameter::lpbc=.true.& !< if LPBC = .TRUE. then periodic boundaries are used
   ,lpbcx=.true.& !< if LPBCX = .TRUE. then periodic boundary in x-directions is used
   ,lpbcy=.true.& !< if LPBCY = .TRUE. then periodic boundary in y-directions is used
   ,lpbcz=.true.& !< if LPBCZ = .TRUE. then periodic boundary in z-directions is used
   ,lfold=.true. !< if LFOLD = .TRUE. then coordinates are always folded into central box

  !*** PARAMETERS FOR INTERACTION CUT-OFFS ***
  logical::lijall& !< if LIJALL = .TRUE. then all i-j interactions are considered (no potential cut-off). Must set lcutcm and ltailc to false for lijall = true *** check top of sumup.f if lijall = true and lchgall is false
   ,lchgall& !< if LCHGALL= .TRUE. then all the electrostatic interaction are considered
   ,lewald& !< if LEWALD=.TRUE. then ewald-sum will be used to calculate the electrostatic interactions.
   ,lcutcm !< if LCUTCM=.TRUE. then a cutoff of the centers of mass will be used with a value of rcmu as calculated in ctrmas

  !*** PARAMETERS FOR TAIL CORRECTIONS ***
  logical::ltailc& !< if LTAILC=.TRUE. tail corrections are added (WARNING: .lsami. in external.inc switches an intrinsic tail correction on)
   ,lshift& !< truncated and shifted potentials
   ,ltailcZeo

  !*** PARAMETERS FOR CBMC-PSEUDO-POTENTIAL ***
  logical::ldual !< if LDUAL=.TRUE. then the external potential during a CBMC growth will only go out to a radius of rcutin and then will be corrected to the full rcut at the end. This is Dual Cutoff Configurational-bias Monte Carlo (DC-CBMC)

  !*** PARAMETERS OF NEIGHBOR LIST ***
  logical::lneigh !< if LNIEGH=.TRUE. the nearest neighbor list will be used with a value of rcutnn specified by fort.4

  !* PARAMETER FOR LENNARD-JONES 12-6
  logical::llj !< This is only used if you are using regular lj potential, i.e. without shifting or modifying it in any other way.

  !* PARAMETERS FOR EXP-6 POTENTIAL
  logical::lexpsix !< if LEXPSIX=.TRUE. exp-6 potential will be used instead of lennard jones

  !* PARAMETERS FOR BUFFERED 14-7 POTENTIAL
  logical::lmmff !< if LMMFF=.TRUE. buffered 14-7 potential will be used.

  !* PARAMETERS FOR 9-6 POTENTIAL
  logical::lninesix !< if LNINESIX=.TRUE. then the 9-6 potential will be used.

  !* PARAMETERS FOR GENERALIZED LJ POTENTIAL
  logical::lgenlj !< if LGENLJ=.TRUE. then the the Generalized lennard jones potential will be used.

  !*** External surface ***
  logical::lexzeo& !< implicit rigid framework for zeolites and metal-organic frameworks. Parameters for zeolites are read in subroutine SUZEO
   ,lzgrid !< whether to use tabulated potential for the interactions with the rigid framework
  logical::lsami& !<
   ,lmuir& !<
   ,lslit& !< planar slit pore
   ,lgraphite& !< graphite surface
   ,ljoe& !<
   ,lpsurf& !<
   ,lcorreg& !<
   ,lelect_field !< external electric field
  real,allocatable::Elect_field(:)

  !*** Thermodynamic integration ***
  real,allocatable::rxwell(:,:),rywell(:,:),rzwell(:,:),sxwell(:,:),sywell(:,:),szwell(:,:),vwellipswot(:),vwellipswnt(:),vipswnt(:),vipswot(:),awell(:,:,:)
  integer,allocatable::nwell(:)
  logical,allocatable::lwell(:)
  integer,parameter::nw=4000
  integer::iratipsw
  real::dvdl,vipsw,pipsw,vwellipsw,pwellipsw,etais,lambdais,bwell,vipswo,vipswn,vwellipswo,vwellipswn,lena,lenc,pwellips(3,3),pips(3,3),dhmat(3,3)
  logical::lstagea,lstageb,lstagec

  !=== Analysis ===
  integer,parameter::nEnergy=14
  real,allocatable::vbox(:,:) !< (j,ibox): energies of ibox; j = 1: total energy; 2: intermolecular LJ; 3: tail correction; 4: intramolecular non-bonded LJ; 5: stretching; 6: bending; 7: torsion; 8: electrostatic; 9: external field; 10: 3-body garofalini; 11: fluctuating charge (vflucqb); 12: vipswb; 13: vwellipswb; 14: Ewald reciprocal-space electrostatic
  integer,allocatable::ucheck(:) !< whether or not to calculate chemical potential for each molecule type
  integer::io_output=6,iprint,imv,iratp,iblock,idiele,iheatcapacity,nprop,ianalyze,nbin
  real::bin_width
  logical::L_movie_xyz,lrdf,lintra,lstretch,lgvst,lbend,lete,lrhoz,lucall

  !*** Histograms for grand-canonical ensemble ***
  integer::nequil,ninstf,ninsth,ndumph

  !*** 2nd virial coefficient ***
  real,allocatable::xiq(:),jayself(:),ecut(:),jayq(:)
  integer,parameter::maxvir=1,maxntemp=3 !< maximum number of bins for the 2nd virial coefficient
  integer::ntemp,nvirial
  real::virtemp(maxntemp),starvir,stepvir

  !*** Dielectric constant ***
  real,allocatable::dipolex(:),dipoley(:),dipolez(:)
  real::dipolexo,dipoleyo,dipolezo

  !*** RPLC ***
  logical,allocatable::lrplc(:)& !< if lrplc=.true. there are some special rules in CBMC for how to grow chains
   ,ltwice(:) !< if ltwice=.true. then mimage is applied twice

  !=== Force field parameters ===
  integer::nntype !< number of types of beads
  real,allocatable::mass(:),sigi(:),epsi(:),qelect(:),sig2ij(:),epsij(:)&
   ,brvib(:),brvibk(:),brben(:),brbenk(:)&
   ,ljscale(:,:,:),qscale2(:,:,:)
  character(len=4),allocatable::chemid(:)
  integer,allocatable::a15type(:,:,:)
  logical,allocatable::lij(:),lqchg(:),lexclu(:,:,:,:),linclu(:,:,:),lqinclu(:,:,:),lainclu(:,:,:),lpl(:)

  !*** Garofalini force field ***
  logical::lgaro !< if LGARO=.TRUE. garofalini potential will be used instead of Lennard-Jones
  real::v3garo

  !=== Information about simulation box ===
  integer::nbox=1,nbxmax& !< maximum number of boxes
   ,npabmax& !< maximum number of box pairs (for swatch and swap)
   ,boxlink
  real::beta
  logical::licell
  real,allocatable,target::boxlx(:),boxly(:),boxlz(:),rcut(:),rcutnn(:),kalp(:)
  logical,allocatable,target::lsolid(:),lrect(:)
  real,allocatable::express(:),B(:) !< chemical potential
  integer,allocatable::ghost_particles(:),numberDimensionIsIsotropic(:)
  logical,allocatable::lideal(:) !< if lideal=.true. then intermolecular interactions are not computed

  !=== Information about molecule types ===
  integer::nmolty=1,ntmax& !< maximum number of types of chains
   ,npamax& !< maximum number of pairs to switch or swatch
   ,numax !< maximum number of units
  integer,allocatable::nunit(:),isolute(:),rindex(:),riutry(:,:)
  logical,allocatable::lelect(:),lrigid(:),lq14scale(:)
  real,allocatable::eta2(:,:),qscale(:)
  integer,allocatable::ntype(:,:),leaderq(:,:)&
   ,invib(:,:),itvib(:,:,:),ijvib(:,:,:)&
   ,inben(:,:),itben(:,:,:),ijben2(:,:,:),ijben3(:,:,:)&
   ,intor(:,:),ittor(:,:,:),ijtor2(:,:,:),ijtor3(:,:,:),ijtor4(:,:,:)

  !=== Information about particles in the system ===
  integer::nchain=4,nmax !< maximum number of chains + 2
  integer,allocatable::moltyp(:),nboxi(:)
  real,allocatable::masst(:),rcmu(:),xcm(:),ycm(:),zcm(:)& !< center-of-mass coordinates of each chain
   ,sxcm(:),sycm(:),szcm(:)& !< center-of-mass coordinates of each chain in scaled units, for use in non-orthorhombic simulation cells
   ,rxu(:,:),ryu(:,:),rzu(:,:),qqu(:,:)

  !=== Counters ===
  integer,allocatable::ncmt(:,:)& !< (ibox,itype): number of molecules of itype in ibox
   ,ncmt2(:,:,:)& !< (ibox,itype,itype2): number of molecules of itype in ibox, in stage itype2 as in expanded ensemble
   ,nchbox(:)& !< number of molecules (of any type) in each box
   ,parall(:,:)& !< (itype,j): index of the j-th molecule of itype
   ,parbox(:,:,:)& !< (j,ibox,itype): index of j-th molecule of itype in ibox
   ,temtyp(:) !< number of molecules of each molecule type

  !=== Information about Monte Carlo moves ===
  integer::tmcc,iratio
  logical::lstop
  real::rmin,softcut,softlog

  !*** Volume moves ***
  real::pmvol,pmvolx,pmvoly,tavol
  real,allocatable::pmvlmt(:),pmvolb(:),rmvol(:),rmhmat(:,:)
  integer::nvolb,iratv
  integer,allocatable::box5(:),box6(:)

  !*** CBMC particle identity switch (swatch) moves ***
  real::pmswat
  integer::nswaty
  real,allocatable::pmsatc(:),pmswtcb(:,:)
  integer,allocatable::nswatb(:,:),nsampos(:),ncut(:,:),splist(:,:,:),gswatc(:,:,:),nswtcb(:),box3(:,:),box4(:,:)
  logical,allocatable::liswinc(:,:)
  logical::liswatch
  integer::other

  !*** CBMC particle transfer (swap) moves ***
  real::pmswap
  real,allocatable::pmswmt(:),pmswapb(:,:)
  integer,allocatable::nswapb(:),box1(:,:),box2(:,:)

  !** AVBMC moves **
  logical,allocatable::lavbmc1(:),lavbmc2(:),lavbmc3(:),lbias(:)
  real,allocatable::pmbias(:),pmbsmt(:),pmbias2(:),favor(:),favor2(:)
  real::rintramax,rbsmax,rbsmin,vol_eff

  !* Nucleation *
  integer,allocatable::neighbor(:,:),neigh_cnt(:),neighboro(:,:),neigh_o(:)
  real,allocatable::ndij(:,:),nxij(:,:),nyij(:,:),nzij(:,:),ndijo(:,:),nxijo(:,:),nyijo(:,:),nzijo(:,:)
  integer,parameter::maxneigh=20
  real::ndiji(maxneigh),nxiji(maxneigh),nyiji(maxneigh),nziji(maxneigh)
  integer::neigh_icnt,neighi(maxneigh)
  logical::lneighbor

  !*** Regular CBMC moves ***
  real::pmcb
  real,allocatable::pmcbmt(:),pmall(:)

  !** SAFE CBMC **
  real,allocatable::pmfix(:)
  integer,allocatable::iring(:),nrig(:),irig(:,:),frig(:,:),nrigmin(:),nrigmax(:)
  logical,allocatable::lring(:),lrig(:),lrigi(:,:)
  integer,parameter::maxbin=201 !< SAFECBMC max number of bins
  integer::iupdatefix
  logical::lpresim

  !*** CBMC shared variables ***
  integer,allocatable::nugrow(:),nmaxcbmc(:),iurot(:),maxgrow(:)&
   ,nchoi1(:),nchoi(:),nchoir(:),nchoih(:),nchtor(:),nchbna(:),nchbnb(:)&
   ,nrotbd(:),irotbd(:,:),icbdir(:),icbsta(:)&
   ,growfrom(:),growprev(:),grownum(:),growlist(:,:)
  real,allocatable::pmrotbd(:,:),rxp(:,:),ryp(:,:),rzp(:,:)& !< (iunit,itrial) coordinates of iunit of the selected molecule for the itrial-th candidate configuration, for use in rosenbluth
   ,bfac(:),vtr(:,:),vtrorient(:),vtrelect_intra(:),vtrelect_inter(:)& !< Boltzmann factors and energies for the configuration in r{x,y,z}p
   ,rxuion(:,:),ryuion(:,:),rzuion(:,:),qquion(:,:)& !< (iunit,flag): coordinates of iunit of the selected molecule in its old (flag=1) or new (flag=2) state, for subroutine energy (one-particle energy)
   ,rxnew(:),rynew(:),rznew(:)& !< coordinates of iunit of the selected molecule in its new configuration, for use in config, swap and swatch
   ,xvec(:,:),yvec(:,:),zvec(:,:)
  logical,allocatable::lovr(:),lexist(:),lplace(:,:)
  integer::nchmax& !< maximum number of choices for trial sites in CBMC growth
   ,nchtor_max& !< maximum number of choices for torsion CBMC growth
   ,nchbn_max& !< maxium number of choices for bending CBMC growth
   ,moltion(2)
  real::rcutin,weight,weiold,vold(nEnergy),vnew(nEnergy),vneworient,voldorient
  logical::L_Coul_CBMC

  !*** Fluctuating charge moves ***
  logical,parameter::lfepsi=.false. !< If lfepsi is true, the fluctuation of epsilon is used instead of the fluctuation of the sigma.
  logical,allocatable::lflucq(:),lqtrans(:)
  real::pmflcq,taflcq,fqbeta
  real,allocatable::bnflcq(:,:),bsflcq(:,:),bnflcq2(:,:),bsflcq2(:,:)& !< accumulators for statistics of fluctuating charge moves; bnflcq and bsflcq record the number of all and successful attempts between updates of maximum displacements, while bnflcq2 and bsflcq record the values for the entire run
   ,fqegp(:),pmfqmt(:),rmflcq(:,:)

  !*** Expanded ensemble moves ***
  integer,parameter::smax=35 !< max no. of mstates
  logical::leemove,lmstate,leeacc
  integer::fmstate,sstate1,sstate2,nstate,box_state(smax),eepointp,eeirem,boxrem1,boxins1,ee_prob(smax)
  real::wee_ratio,psi(smax),um_markov(smax,smax),eeratio
  integer::mstate,ee_moltyp(smax),nmolty1
  logical,allocatable::lexpand(:)
  real::pmexpc
  real,allocatable::pmeemt(:),sigma_f(:,:),epsilon_f(:,:),ee_qqu(:,:),rminee(:)
  integer,allocatable::rmexpc(:),eetype(:)

  !*** New expanded ensemble moves ***
  real::pmexpc1

  !*** Atom translation ***
  real::pm_atom_tra,Armtrax,Armtray,Armtraz

  !*** Translation ***
  real::pmtra,tatra
  real,allocatable::pmtrmt(:),rmtrax(:,:),rmtray(:,:),rmtraz(:,:)

  !*** Rotation ***
  real::tarot
  real,allocatable::pmromt(:),rmrotx(:,:),rmroty(:,:),rmrotz(:,:)

  !=== MPI-related ===
  integer::myid,numprocs,groupid
  integer,parameter::rootid=0

  !=== OPENMP-related ===
  integer::thread_id,thread_num,thread_num_max,thread_num_proc

  real,allocatable::zshift(:),dshift(:)
  integer,allocatable::ininch(:,:),inix(:),iniy(:),iniz(:),inirot(:),inimix(:),nchoiq(:)
  logical,allocatable::lbranch(:)
  integer::run_num
  character(LEN=1)::suffix
  logical::L_add,L_sub
  integer::N_add,N_box2add,N_moltyp2add
  integer::N_sub,N_box2sub,N_moltyp2sub
  real::Num_cell_a,Num_cell_b,Num_cell_c
  logical::L_tor_table,L_spline,L_linear,L_vib_table,L_bend_table,L_vdW_table,L_elect_table
  real::temp

  !** Parameters for 2nd virial coefficient calculation ***
  ! real,parameter::a0 = 0.2003E0_dp,b0 = 1.3946E0_dp,aslope = 8.85E5_dp,bslope = 158.25E0_dp,ashift = 7.227E5_dp,bshift = 505.97E0_dp ! slope=0.3 a=3.05
  ! real,parameter::a0 = 0.15561E0_dp,b0 = 1.2960E0_dp,aslope = 5.5475E5_dp,bslope = 131.23E0_dp,ashift = 4.121E5_dp,bshift = 381.96E0_dp ! slope=0.3 a=2.90
  ! real,parameter::a0 = 0.16833E0_dp,b0 = 1.3299E0_dp,aslope = 6.5125E5_dp,bslope = 139.75E0_dp,ashift = 4.9975E5_dp,bshift = 419.81E0_dp ! slope=0.3 a=2.95
  ! real,parameter::a0 = 0.13150E0_dp,b0 = 1.2574E0_dp,aslope = 4.2863E5_dp,bslope = 117.5E0_dp,ashift = 3.0208E5_dp,bshift = 323.6E0_dp ! slope=0.3 a=2.82
  ! real,parameter::a0 = 0.11037E0_dp,b0 = 1.1942E0_dp,aslope = 3.4013E5_dp,bslope = 108E0_dp,ashift = 2.2868E5_dp,bshift = 285.04E0_dp ! slope=0.3 a=2.75
  ! real,parameter::a0 = 0.14035E0_dp,b0 = 1.2596E0_dp,aslope = 4.7263E5_dp,bslope = 123.25E0_dp,ashift = 3.3978E5_dp,bshift = 347.63E0_dp ! slope=0.3 a=2.85
  ! real,parameter::a0 = 0.14820E0_dp,b0 = 1.2689E0_dp,aslope = 5.2125E5_dp,bslope = 128.75E0_dp,ashift = 3.8220E5_dp,bshift = 371.29E0_dp ! slope=0.3 a=2.88
  real,parameter::a0 = -0.22818E0_dp,b0 = 0.44662E0_dp,aslope = 14.0738E5_dp,bslope = 351.25E0_dp,ashift = 3.5852E5_dp,bshift = 358.94E0_dp ! slope=0.5 a=2.71
  !	real,parameter::a0 = -0.23379E0_dp,b0 = 0.43630E0_dp,aslope = 12.78125E5_dp,bslope = 337.5E0_dp,ashift = 3.1904E5_dp,bshift = 337.86E0_dp ! slope=0.5 a=2.68
  !	real,parameter::a0 = -0.23808E0_dp,b0 = 0.425507E0_dp,aslope = 11.7775E5_dp,bslope = 322.04E0_dp,ashift = 2.8902E5_dp,bshift = 326.875E0_dp ! slope=0.5 a=2.655
  !	real,parameter::a0 = -0.23641E0_dp,b0 = 0.43409E0_dp,aslope = 12.171E5_dp,bslope = 330E0_dp,ashift = 3.0075E5_dp,bshift = 326.52E0_dp ! slope=0.5 a=2.665
  !	real,parameter::a0 = -0.23903E0_dp,b0 = 0.42231E0_dp,aslope = 11.5875E5_dp,bslope = 325E0_dp,ashift = 2.8339E5_dp,bshift = 319.44E0_dp ! slope=0.5 a=2.65
  !	real,parameter::a0 = -0.24796E0_dp,b0 = 0.40345E0_dp,aslope = 9.8238E5_dp,bslope = 304E0_dp,ashift = 2.3206E5_dp,bshift = 288.72E0_dp ! slope=0.5 a=2.60
  !	real,parameter::a0 = -0.25703E0_dp,b0 = 0.38299E0_dp,aslope = 8.3075E5_dp,bslope = 284.38E0_dp,ashift = 1.8945E5_dp,bshift = 261.09E0_dp ! slope=0.5 a=2.55
  !	real,parameter::a0 = -0.39106E0_dp,b0 = 0.08431E0_dp,aslope = 25.22875E5_dp,bslope = 662.75E0_dp,ashift = 3.0689E5_dp,bshift = 335.43E0_dp ! slope = 0.7 a=2.52
  !	real,parameter::a0 = -0.39233E0_dp,b0 = 0.08203E0_dp,aslope = 24.425E5_dp,bslope = 653.75E0_dp,ashift = 2.9499E5_dp,bshift = 328.60E0_dp ! slope = 0.7 a=2.51
  !	real,parameter::a0 = -0.39357E0_dp,b0 = 0.07946E0_dp,aslope = 23.641E5_dp,bslope = 645E0_dp,ashift = 2.835E5_dp,bshift = 322.13E0_dp ! slope = 0.7 a=2.50
  !	real,parameter::a0 = -0.394906E0_dp,b0 = 0.075678E0_dp,aslope = 22.88625E5_dp,bslope = 637.735E0_dp,ashift = 2.72469E5_dp,bshift = 316.22E0_dp ! slope = 0.7 a=2.49
  !	real,parameter::a0 = -0.396175E0_dp,b0 = 0.072973E0_dp,aslope = 22.149125E5_dp,bslope = 629E0_dp,ashift = 2.61798E5_dp,bshift = 309.95E0_dp ! slope = 0.7 a=2.48
  !	real,parameter::a0 = -0.39745E0_dp,b0 = 0.070157E0_dp,aslope = 21.4335E5_dp,bslope = 620.75E0_dp,ashift = 2.5151E5_dp,bshift = 306.89E0_dp ! slope = 0.7 a=2.47
  !	real,parameter::a0 = -0.399983E0_dp,b0 = 0.064159E0_dp,aslope = 20.06425E5_dp,bslope = 604.75E0_dp,ashift = 2.32037E5_dp,bshift = 292.09E0_dp ! slope = 0.7 a=2.45
  !	real,parameter::a0 = -0.40629E0_dp,b0 = 0.050088E0_dp,aslope = 16.9775E5_dp,bslope = 565.50E0_dp,ashift = 1.89213E5_dp,bshift = 263.93E0_dp ! slope = 0.7 a=2.40
  !	real,parameter::a0 = -0.48332E0_dp,b0 = -0.12334E0_dp,aslope = 34.64125E5_dp,bslope = 1014.25E0_dp,ashift = 2.2815E5_dp,bshift = 294.26E0_dp ! slope = 0.9 a=2.30
  !	real,parameter::a0 = -0.48137E0_dp,b0 = -0.11887E0_dp,aslope = 36.99125E5_dp,bslope = 1041.25E0_dp,ashift = 2.4744E5_dp,bshift = 306.23E0_dp ! slope = 0.9 a=2.32
  !	real,parameter::a0 = 0.0E0_dp,b0 = 0.0E0_dp,aslope = 3.0E5_dp,bslope = 0.0E0_dp,ashift = 8.0E5_dp,bshift = 1200.0E0_dp ! slope = 0.3 a=2.85

  namelist /system/nchain,nmolty,nbox

  type(LookupTable)::atoms

CONTAINS
  subroutine allocate_cell()
    integer::jerr
    allocate(boxlx(nbxmax),boxly(nbxmax),boxlz(nbxmax),rcut(nbxmax),rcutnn(nbxmax),kalp(nbxmax),lsolid(nbxmax),lrect(nbxmax)&
     ,express(nbxmax),Elect_field(nbxmax),ghost_particles(nbxmax),numberDimensionIsIsotropic(nbxmax),inix(nbxmax),iniy(nbxmax)&
     ,iniz(nbxmax),inirot(nbxmax),inimix(nbxmax),nchoiq(nbxmax),box5(nbxmax),box6(nbxmax),zshift(nbxmax),dshift(nbxmax)&
     ,rmvol(nbxmax),pmvlmt(nbxmax),pmvolb(nbxmax),lideal(nbxmax),ltwice(nbxmax),rmhmat(nbxmax,9),dipolex(nbxmax),dipoley(nbxmax)&
     ,dipolez(nbxmax),nchbox(nbxmax),vbox(nEnergy,nbxmax),stat=jerr)
    if (jerr.ne.0) then
       call err_exit(__FILE__,__LINE__,'allocate_system: allocation failed',jerr)
    end if
  end subroutine allocate_cell

  subroutine allocate_system()
    integer,parameter::initial_size=15
    integer::jerr
    allocate(ucheck(ntmax),nrotbd(ntmax),xcm(nmax),ycm(nmax),zcm(nmax),pmsatc(npamax),pmswtcb(npamax,npabmax),nswatb(npamax,2)&
     ,nsampos(npamax),ncut(npamax,2),gswatc(npamax,2,2*npamax),nswtcb(npamax),box3(npamax,npabmax),box4(npamax,npabmax)&
     ,temtyp(ntmax),B(ntmax),nunit(ntmax),nugrow(ntmax),nmaxcbmc(ntmax),iurot(ntmax)&
     ,maxgrow(ntmax),isolute(ntmax),iring(ntmax),nrig(ntmax),irig(ntmax,6),frig(ntmax,6),nrigmin(ntmax),nrigmax(ntmax)&
     ,rindex(ntmax),riutry(ntmax,3),lelect(ntmax),lflucq(ntmax),lqtrans(ntmax),lexpand(ntmax),lavbmc1(ntmax),lavbmc2(ntmax)&
     ,lavbmc3(ntmax),lbias(ntmax),lring(ntmax),lrigid(ntmax),lrig(ntmax),lq14scale(ntmax),fqegp(ntmax),eta2(nbxmax,ntmax)&
     ,qscale(ntmax),pmbias(ntmax),pmbsmt(ntmax),pmbias2(ntmax),rmtrax(ntmax,nbxmax),rmtray(ntmax,nbxmax),rmtraz(ntmax,nbxmax)&
     ,rmrotx(ntmax,nbxmax),rmroty(ntmax,nbxmax),rmrotz(ntmax,nbxmax),lbranch(ntmax),ininch(ntmax,nbxmax),rmflcq(ntmax,nbxmax)&
     ,pmswmt(ntmax),pmswapb(ntmax,npabmax),pmcbmt(ntmax),pmall(ntmax),pmfix(ntmax),pmfqmt(ntmax),pmeemt(ntmax),pmtrmt(ntmax)&
     ,pmromt(ntmax),nswapb(ntmax),box1(ntmax,npabmax),box2(ntmax,npabmax),nchoi1(ntmax),nchoi(ntmax),nchoir(ntmax)&
     ,nchoih(ntmax),nchtor(ntmax),nchbna(ntmax),nchbnb(ntmax),icbdir(ntmax),icbsta(ntmax),lrplc(ntmax),masst(ntmax)&
     ,rmexpc(ntmax),eetype(ntmax),ncmt(nbxmax,ntmax),ncmt2(nbxmax,ntmax,20),parall(ntmax,nmax)&
     ,parbox(nmax,nbxmax,ntmax),bnflcq(ntmax,nbxmax),bsflcq(ntmax,nbxmax)&
     ,bnflcq2(ntmax,nbxmax),bsflcq2(ntmax,nbxmax),rxwell(nw,ntmax),rywell(nw,ntmax),rzwell(nw,ntmax),sxwell(nw,ntmax)&
     ,sywell(nw,ntmax),szwell(nw,ntmax),nwell(ntmax),lwell(ntmax),moltyp(nmax),rcmu(nmax),sxcm(nmax),sycm(nmax),szcm(nmax),nboxi(nmax)&
     ,neighbor(maxneigh,nmax),neigh_cnt(nmax),neighboro(maxneigh,nmax),neigh_o(nmax),ndij(maxneigh,nmax),nxij(maxneigh,nmax)&
     ,nyij(maxneigh,nmax),nxijo(maxneigh,nmax),nzij(maxneigh,nmax),ndijo(maxneigh,nmax),nyijo(maxneigh,nmax),nzijo(maxneigh,nmax)&
     ,favor(nmax),favor2(nmax),ntype(ntmax,initial_size),leaderq(ntmax,initial_size),lplace(ntmax,initial_size)&
     ,lrigi(ntmax,initial_size),invib(ntmax,initial_size),itvib(ntmax,initial_size,6),ijvib(ntmax,initial_size,6)&
     ,inben(ntmax,initial_size),itben(ntmax,initial_size,12),ijben2(ntmax,initial_size,12),ijben3(ntmax,initial_size,12)&
     ,intor(ntmax,initial_size),ittor(ntmax,initial_size,12),ijtor2(ntmax,initial_size,12),ijtor3(ntmax,initial_size,12)&
     ,ijtor4(ntmax,initial_size,12),irotbd(initial_size,ntmax),pmrotbd(initial_size,ntmax),stat=jerr)
    if (jerr.ne.0) then
       call err_exit(__FILE__,__LINE__,'allocate_system: allocation failed',jerr)
    end if
  end subroutine allocate_system

  subroutine allocate_molecule()
    integer::jerr
    allocate(splist(npamax,numax,2),lexist(numax),lexclu(ntmax,numax,ntmax,numax),liswinc(numax,ntmax)&
     ,a15type(ntmax,numax,numax),epsilon_f(2,numax),sigma_f(2,numax),ljscale(ntmax,numax,numax),qscale2(ntmax,numax,numax)&
     ,ee_qqu(numax,smax),rxnew(numax),rynew(numax),rznew(numax),rxu(nmax,numax),ryu(nmax,numax)&
     ,rzu(nmax,numax),qqu(nmax,numax),rxuion(numax,2),ryuion(numax,2),rzuion(numax,2),qquion(numax,2)&
     ,linclu(ntmax,numax,numax),lqinclu(ntmax,numax,numax),lainclu(ntmax,numax,numax)&
     ,xvec(numax,numax),yvec(numax,numax),zvec(numax,numax),growfrom(numax)&
     ,growprev(numax),grownum(numax),growlist(numax,numax),awell(numax,numax,ntmax),stat=jerr)
    if (jerr.ne.0) then
       call err_exit(__FILE__,__LINE__,'allocate_molecule: allocation failed',jerr)
    end if
  end subroutine allocate_molecule

  subroutine checkAtom()
    if (.not.allocated(atoms%list)) call err_exit(__FILE__,__LINE__,": ATOMS section has not been defined!",myid+1)
  end subroutine checkAtom
end module sim_system
